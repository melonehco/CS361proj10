/*
 * Authors: Haoyu Song and Dale Skrien
 * Date: Spring and Summer, 2018
 *
 * In the grammar below, the variables are enclosed in angle brackets.
 * The notation "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * All other symbols in the rules are terminals.
 * EMPTY indicates a rule with an empty right hand side.
 * All other terminal symbols that are in all caps correspond to keywords.
 */

package proj10AbulhabFengMaoSavillo.bantam.parser;

import proj10AbulhabFengMaoSavillo.bantam.lexer.*;
import proj10AbulhabFengMaoSavillo.bantam.util.*;

import static proj10AbulhabFengMaoSavillo.bantam.lexer.Token.Kind.*;

import proj10AbulhabFengMaoSavillo.bantam.ast.*;
import proj10AbulhabFengMaoSavillo.bantam.util.Error;
import sun.tools.java.Identifier;


/**
 * This class constructs an AST from a legal Bantam Java program.  If the
 * program is illegal, then one or more error messages are displayed.
 */
public class Parser
{
    // instance variables
    private Scanner scanner;
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler;
    private String filename;

    // constructor
    public Parser(ErrorHandler errorHandler)
    {
        this.errorHandler = errorHandler;
        scanner = new Scanner(errorHandler);
    }

    /**
     * Test code for Parser
     */
    public static void main(String[] args)
    {
        //make sure at least one filename was given
        if (args.length < 1)
        {
            System.err.println("Missing input filename");
            System.exit(-1);
        }

        //for each file given, scan
        ErrorHandler errorHandler = new ErrorHandler();
        for (String filename : args)
        {
            System.out.println("Scanning file: " + filename + "\n");

            //scan tokens
            try
            {
//				Scanner scanner = new Scanner(filename, errorHandler);
//				Token currentToken = scanner.scan();
//				while (currentToken.kind != Token.Kind.EOF)
//				{
//					System.out.println(currentToken);
//					currentToken = scanner.scan();
//				}
                Parser parser = new Parser(errorHandler);
                parser.parse(filename);
            }
            catch (CompilationException e)
            {
                errorHandler.register(Error.Kind.LEX_ERROR, "Failed to read in source file");
            }

            //check for errors
            if (errorHandler.errorsFound())
            {
                System.out.println(String.format("\n%d errors found", errorHandler.getErrorList().size()));
            }
            else
            {
                System.out.println("\nScanning was successful");
            }

            System.out.println("-----------------------------------------------");

            //clear errors to scan next file
            errorHandler.clear();
        }
    }

    /**
     * parse the given file and return the root node of the AST
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename)
    {
        this.scanner.setSourceFile(filename);
        this.currentToken = scanner.scan();
        this.filename = filename;
        return (parseProgram());
    }

    /*
     * <Program> ::= <Class> | <Class> <Program>
     */
    private Program parseProgram()
    {
        this.advancePastCommentary();
        int position = this.currentToken.position;
        ClassList classList = new ClassList(position);

        while (currentToken.kind != EOF)
        {
            Class_ aClass = parseClass();
            classList.addElement(aClass);
        }

        return new Program(position, classList);
    }

    /**
     * Eats comments
     */
    private void advancePastCommentary()
    {
        while (this.currentToken.kind == COMMENT)
        {
            this.currentToken = this.scanner.scan();
        }
    }

    /*
     * <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
     * <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
     * <MemberList> ::= EMPTY | <Member> <MemberList>
     */
    private Class_ parseClass()
    {
        this.advancePastCommentary();
        int initialPosition = this.currentToken.position;
        String className = "";
        String parent = "";
        MemberList memberList = new MemberList(initialPosition);

        if (this.currentToken.kind == CLASS)
        {
            this.currentToken = this.scanner.scan();
            if (this.currentToken.kind == IDENTIFIER)
            {
                className = this.currentToken.spelling;
            }
            else
            {
                this.whinge("Expecting valid class name in class declaration.");
            }

            this.currentToken = scanner.scan();
            if (this.currentToken.kind == EXTENDS)
            {
                this.currentToken = scanner.scan();
                if (this.currentToken.kind == IDENTIFIER)
                {
                    parent = this.currentToken.spelling;
                    this.currentToken = scanner.scan();
                }
                else
                {
                    this.whinge("Missing name of class to extend in class declaration.");
                }
            }

            if (this.currentToken.kind != LCURLY)
            {
                this.whinge("Expected left brace.");
            }

            while (this.currentToken.kind != RCURLY)
            {
                Member member = parseMember();
                memberList.addElement(member);
            }

            this.currentToken = this.scanner.scan();

            Class_ class_ = new Class_(initialPosition, this.filename, className, parent, memberList);
            System.out.println(class_.getFilename());
            System.out.println(class_.getName());
            System.out.println(class_.getParent());
            System.out.println(class_.getMemberList());

        }

        return new Class_(initialPosition, className, className, parent, memberList);
    }

    /**
     * Parsing Error occurred!
     *
     * @param errorMessage
     * @throws CompilationException
     */
    private void whinge(String errorMessage)
            throws CompilationException
    {
        this.errorHandler.register(Error.Kind.PARSE_ERROR,
                                   this.filename,
                                   this.currentToken.position,
                                   errorMessage);
        throw new CompilationException(String.format("Compilation Exception: %s", errorMessage));
    }

    /* Fields and Methods
     * <Member> ::= <Field> | <Method>
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <InitialValue> ::= EMPTY | = <Expression>
     */
    private Member parseMember()
    {
        int position = currentToken.position;
        String type = this.parseType();
        String nameIdentifier = this.parseIdentifier();
        Member member = null;

        //if member matches form for a method
        if (this.currentToken.kind == LPAREN)
        {
            scanner.scan();
            FormalList params = this.parseParameters();

            //check for closing parenthesis
            if (this.currentToken.kind != RPAREN)
            {
                this.whinge("Missing closing parenthesis in method declaration.");
            }
            else //if present, move on to next token
            {
                this.currentToken = scanner.scan();
            }

            BlockStmt block = (BlockStmt) this.parseBlock();
            StmtList blockStmts = block.getStmtList();

            member = new Method(position, type, nameIdentifier,
                                params, blockStmts);
        }
        else //otherwise parse member as field
        {
            if (this.currentToken.kind == SEMICOLON)
            {
                //TODO: is it okay to have null for an empty init value?
                //empty initial value
                member = new Field(position, type, nameIdentifier, null);
            }
            else if (this.currentToken.kind == ASSIGN)
            {
                //non-empty initial value
                scanner.scan(); //read past =
                Expr initValueExpr = this.parseExpression();

                //check for semicolon
                if (this.currentToken.kind != SEMICOLON)
                {
                    this.whinge("Missing ending semicolon in field declaration.");
                }
                else
                {
                    member = new Field(position, type, nameIdentifier, initValueExpr);
                }
            }
            else
            {
                //invalid syntax
                this.whinge("Invalid field declaration.");
            }
            
            //move past ending semicolon
            this.currentToken = this.scanner.scan();
        }

        return member;
    }

    //-----------------------------------

    /*
     * <BlockStmt> ::= { <Body> }
     * <Body> ::= EMPTY | <Stmt> <Body>
     */
    private Stmt parseBlock()
	{
		int initialPosition = currentToken.position;
		String type = this.parseType();
		String nameIdentifier = this.parseIdentifier();
		BlockStmt blockStmt = null;

		scanner.scan();
		if (this.currentToken.kind == LCURLY)
		{
			StmtList stmtList = new StmtList(initialPosition);
			blockStmt = new BlockStmt(initialPosition, stmtList);
			while (this.currentToken.kind != RCURLY)
			{
				advancePastCommentary();
				parseStatement();
				// TODO: How can I add the statements to the stmList??
			}
		}
		else
		{
			// TODO: error
			// Does this have to account for blocks with only one line that use no curly braces?
		}

		return blockStmt;
	}

    /*
     * <Expression> ::= <LogicalOrExpr> <OptionalAssignment> TODO: "LogicalOrExpr"??
     * <OptionalAssignment> ::= EMPTY | = <Expression>
     */
    private Expr parseExpression()
	{
		Expr expr;

//		switch (currentToken.kind)
//		{
//			case RCURLY:
//				expr = parseOrExpr();
//				break;
//			case LCURLY:
//				expr = parseAndExpr();
//				break;
//			case VAR:
//				expr = parseEqualityExpr();
//				break;
//			case RETURN:
//				expr = parseEqualityExpr();
//				break;
//			case FOR:
//				expr = parseRelationalExpr();
//				break;
//			case WHILE:
//				expr = parseAddExpr();
//				break;
//			case BREAK:
//				expr = parseMultExpr();
//				break;
//			case BREAK:
//				expr = parseNewCastOrUnary();
//				break;
//			case NEW:
//				expr = parseNew();
//				break;
//			case BREAK:
//				expr = parseCast();
//				break;
//			case BREAK:
//				expr = parseUnaryPrefix();
//				break;
//			case BREAK:
//				expr = parseUnaryPostfix();
//				break;
//			case BREAK:
//				expr = parsePrimary();
//				break;
//			case BREAK:
//				expr = parseExpressionStmt();
//		}

		expr = null;
		return expr;
	}

    /*
     * <Parameters>  ::= EMPTY | <Formal> <MoreFormals>
     * <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals
     */
    private FormalList parseParameters() { }

    /*
     * <Type> ::= <Identifier> <Brackets>
     * <Brackets> ::= EMPTY | [ ]
     */
    private String parseType() { }

    private String parseIdentifier() { }

    /* Statements
     *  <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <DeclStmt>
     *              | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
     */
    private Stmt parseStatement()
    {
        Stmt stmt;

        switch (currentToken.kind)
        {
            case IF:
                stmt = parseIf();
                break;
            case LCURLY:
                stmt = parseBlock();
                break;
            case VAR:
                stmt = parseDeclStmt();
                break;
            case RETURN:
                stmt = parseReturn();
                break;
            case FOR:
                stmt = parseFor();
                break;
            case WHILE:
                stmt = parseWhile();
                break;
            case BREAK:
                stmt = parseBreak();
                break;
            default:
                stmt = parseExpressionStmt();
        }

        return stmt;
    }

    /*
     * <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
     */
    private Stmt parseWhile()
    {
        if(this.currentToken.kind==WHILE){
            int position = this.currentToken.position;
            this.currentToken = this.scanner.scan();
            if(this.currentToken.kind==LPAREN){
                this.currentToken=this.scanner.scan();
                Expr expr = parseExpression();
                this.currentToken = this.scanner.scan();
                if(this.currentToken.kind==RPAREN){
                    this.currentToken=this.scanner.scan();
                    Stmt stmt = parseStatement();
                    return new WhileStmt(position,expr,stmt);
                }
            }
        }
        return null;
    }

    /*
     * <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
     */
    private Stmt parseReturn()
    {
        Expr expr = null;
        if(this.currentToken.kind==RETURN){
            int position = this.currentToken.position;
            this.currentToken=this.scanner.scan();
            if (this.currentToken.kind!=SEMICOLON) {
                expr = parseExpression();
            }
            return new ReturnStmt(position,expr);
        }
        return null;
    }

    /*
     * BreakStmt> ::= BREAK ;
     */
    private Stmt parseBreak()
    {
        if(this.currentToken.kind==BREAK){
            return new BreakStmt(this.currentToken.position);
        }
        return null;
    }

    //-----------------------------------------
    // Expressions
    //Here we introduce the precedence to operations

    /*
     * <ExpressionStmt> ::= <Expression> ;
     */
    private ExprStmt parseExpressionStmt()
    {
        advancePastCommentary();
        int position = this.currentToken.position;
        Expr expr = parseExpression();
        return new ExprStmt(position,expr);
    }

    /*
     * <DeclStmt> ::= VAR <Identifier> = <Expression> ;
     * every local variable must be initialized
     */
    private Stmt parseDeclStmt()
    {
        int position = 0;
        if(this.currentToken.kind==VAR){
            this.currentToken=this.scanner.scan();
            if(this.currentToken.kind==IDENTIFIER){
                String identifier = parseIdentifier();
                this.currentToken=this.scanner.scan();
                if(this.currentToken.kind==ASSIGN){
                    Expr expr = parseExpression();
                    return new DeclStmt(position,identifier,expr);
                }
            }
        }
        return null;
    }

    /*
     * <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
     * <Start>     ::= EMPTY | <Expression>
     * <Terminate> ::= EMPTY | <Expression>
     * <Increment> ::= EMPTY | <Expression>
     */
    private Stmt parseFor()
    {
        int position = 0;
        Expr start = null;
        Expr terminate = null;
        Expr increment = null;

        if (this.currentToken.kind==FOR){
            position = this.currentToken.position;
            this.currentToken=this.scanner.scan();
            if (this.currentToken.kind==LPAREN){
                this.currentToken=this.scanner.scan();
                if(this.currentToken.kind!=SEMICOLON){
                    start = parseExpression();
                }
                else this.currentToken=this.scanner.scan();

                if(this.currentToken.kind!=SEMICOLON){
                    terminate = parseExpression();
                }
                else this.currentToken=this.scanner.scan();

                if (this.currentToken.kind!=RPAREN){
                    increment = parseExpression();
                }
                else this.currentToken=this.scanner.scan();
                Stmt bodyStmt = parseStatement();
                return new ForStmt(position, start,terminate,increment,bodyStmt)
            }
        }
        return null;
    }

    /*
     * <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
     */
    private Stmt parseIf()
    {
        int position = 0;
        Expr expr = null;
        Stmt thenStmt = null;
        Stmt elseStmt = null;

        if(this.currentToken.kind==IF){
            position = currentToken.position;
            this.currentToken = this.scanner.scan();
            if(this.currentToken.kind==LPAREN){
                expr = parseExpression();
                this.currentToken = this.scanner.scan();
                if(this.currentToken.kind==RPAREN){
                    thenStmt = parseStatement();
                    this.currentToken = this.scanner.scan();
                    if(this.currentToken.kind==ELSE){
                        elseStmt = parseStatement();
                        this.currentToken = this.scanner.scan();
                    }
                }
            }
        }
        return new IfStmt(position,expr,thenStmt,elseStmt);
    }

    /*
     * <LogicalOR> ::= <logicalAND> <LogicalORRest>
     * <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
     */
    private Expr parseOrExpr()
    {
        int position = currentToken.position;

        Expr left = parseAndExpr();
        while (this.currentToken.spelling.equals("||"))
        {
            this.currentToken = scanner.scan();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(position, left, right);
        }

        return left;
    }

    /*
     * <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
     * <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
     */
    private Expr parseAndExpr()
    {
        int position = currentToken.position;
        Expr left = parseEqualityExpr();
        while(this.currentToken.spelling.equals("&&")){
            this.currentToken=this.scanner.scan();
            Expr right = parseEqualityExpr();
            left = new BinaryLogicAndExpr(position,left,right);
        }
        return left;


    }

    /*
     * <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
     *                     <RelationalExpr>
     * <equalOrNotEqual> ::=  == | !=
     */
    private Expr parseEqualityExpr()
    {
        int position = currentToken.position;
        Expr left = parseRelationalExpr();
        Expr right = null;
        this.currentToken=scanner.scan();
        if (this.currentToken.spelling=="=="){
            this.currentToken=this.scanner.scan();
            right = parseRelationalExpr();
            return new BinaryCompEqExpr(position,left,right);
        }
        else if (this.currentToken.spelling=="!="){
            this.currentToken=this.scanner.scan();
            right = parseRelationalExpr();
            return new BinaryCompNeExpr(position,left,right);
        }
        else {
            return null;
            //TODO:ERROR
        }

    }

    /*
     * <RelationalExpr> ::=<AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
     * <ComparisonOp> ::=  < | > | <= | >= | INSTANCEOF
     */
    private Expr parseRelationalExpr()
    {
        int position = currentToken.position;
        Expr left = parseRelationalExpr();
        Expr right = null;
        this.currentToken=scanner.scan();
        switch(this.currentToken.spelling)
        {
            case "<":
                this.currentToken=this.scanner.scan();
                right = parseRelationalExpr();
                return new BinaryCompLtExpr(position,left,right);
            case ">":
                this.currentToken=this.scanner.scan();
                right = parseRelationalExpr();
                return new BinaryCompGtExpr(position,left,right);
            case "<=":
                this.currentToken=this.scanner.scan();
                right = parseRelationalExpr();
                return new BinaryCompLeqExpr(position,left,right);
            case ">=":
                this.currentToken=this.scanner.scan();
                right = parseRelationalExpr();
                return new BinaryCompGeqExpr(position,left,right);
        }

        return null;
        //TODO:ERROR

    }

    /*
     * <AddExpr>::Ôºù <MultExpr> <MoreMultExpr>
     * <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
     */
    private Expr parseAddExpr()
    {
        //TODO
        int position = currentToken.position;
        Expr left = parseMultExpr();
        while(this.currentToken.spelling.equals("+")||this.currentToken.spelling.equals("-")){
            this.currentToken=this.scanner.scan();
            Expr right = parseMultExpr();
            if(this.currentToken.spelling=="+")
                left = new BinaryArithPlusExpr(position,left,right);
            else if(this.currentToken.spelling=="-")
                left = new BinaryArithMinusExpr(position,left,right);
        }
        return left;
    }

    /*
     * <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
     * <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
     *               / <NewCastOrUnary> <MoreNCU> |
     *               % <NewCastOrUnary> <MoreNCU> |
     *               EMPTY
     */
    private Expr parseMultExpr() { }

    /*
     * <NewCastOrUnary> ::= <NewExpression> | <CastExpression> | <UnaryPrefix>
     */
    private Expr parseNewCastOrUnary()
    {
    	//determine which rule to follow based on first token
    	if (this.currentToken.kind == NEW)
    	{
    		return this.parseNew();
    	}
    	else if (this.currentToken.kind == CAST)
    	{
    		return this.parseCast();
    	}
    	else
    	{
    		return this.parseUnaryPrefix();
    	}
    }

    /*
     * <NewExpression> ::= NEW <Identifier> ( ) | NEW <Identifier> [ <Expression> ]
     */
	private Expr parseNew()
	{ 
		int position = this.currentToken.position;
		Expr result = null;
		
		this.currentToken = this.scanner.scan(); //move past NEW
		String type = this.parseIdentifier();
		
		//handle new object
		if (this.currentToken.kind == LPAREN)
		{
			result = new NewExpr(position, type);
			
			//check for closing parenthesis
			this.currentToken = this.scanner.scan();
			if (this.currentToken.kind != RPAREN)
			{
				this.whinge("Missing closing parenthesis in new object expression.");
			}
			else
			{
				this.currentToken = this.scanner.scan();
			}
		}
		//handle new array
		else if (this.currentToken.kind == LBRACKET)
		{
			this.currentToken = this.scanner.scan();
			Expr size = this.parseExpression();
			
			result = new NewArrayExpr(position, type, size);
			
			//check for closing bracket
			if (this.currentToken.kind != RBRACKET)
			{
				this.whinge("Missing closing bracket in new array expression.");
			}
			else
			{
				this.currentToken = this.scanner.scan();
			}
		}
		else
		{
			this.whinge("Invalid new object/array expression.");
		}
		
		return result;
	}

    /*
     * <CastExpression> ::= CAST ( <Type> , <Expression> )
     */
	private Expr parseCast()
	{
		int position = this.currentToken.position;
		Expr result = null;
		
		scanner.scan();
		if (this.currentToken.kind != LPAREN)
		{
			this.whinge("Missing opening parenthesis in cast expression.");
		}
		else
		{
			this.currentToken = this.scanner.scan();
			String type = this.parseType();
			
			//check for comma
			this.currentToken = this.scanner.scan();
			if (this.currentToken.kind != COMMA)
			{
				this.whinge("Missing comma in cast expression.");
			}
			
			this.currentToken = this.scanner.scan();
			Expr castedExpr = this.parseExpression();
			result = new CastExpr(position, type, castedExpr);
			
			//check for closing parenthesis
			if (this.currentToken.kind != RPAREN)
			{
				this.whinge("Missing closing parenthesis in cast expression.");
			}
		}
		
		return result;
	}

    /*
     * <UnaryPrefix> ::= <PrefixOp> <UnaryPrefix> | <UnaryPostfix>
     * <PrefixOp> ::= - | ! | ++ | --
     */
	private Expr parseUnaryPrefix()
	{
		int position = this.currentToken.position;
		Expr result = null;
		
		if (this.currentToken.kind == PLUSMINUS)
		{
			//unary negation
			
			//check to make sure not +
			if (this.currentToken.spelling.equals("+"))
			{
				this.whinge("Unexpected + prefix to expression.");
			}
			else
			{
				this.currentToken = this.scanner.scan();
				Expr innerPrefix = this.parseUnaryPrefix();
				result = new UnaryNegExpr(position, innerPrefix);
			}
		}
		else if (this.currentToken.kind == UNARYNOT)
		{
			//unary not
			this.currentToken = this.scanner.scan();
			Expr innerPrefix = this.parseUnaryPrefix();
			result = new UnaryNotExpr(position, innerPrefix);
		}
		else if (this.currentToken.kind == UNARYINCR)
		{
			//pre-increment
			this.currentToken = this.scanner.scan();
			Expr innerPrefix = this.parseUnaryPrefix();
			result = new UnaryIncrExpr(position, innerPrefix, false);
		}
		else if (this.currentToken.kind == UNARYDECR)
		{
			//pre-decrement
			this.currentToken = this.scanner.scan();
			Expr innerPrefix = this.parseUnaryPrefix();
			result = new UnaryDecrExpr(position, innerPrefix, false);
		}
		else
		{
			//no prefix (base case)
			result = this.parseUnaryPostfix();
		}
		
		return result;
	}

    /*
     * <UnaryPostfix> ::= <Primary> <PostfixOp>
     * <PostfixOp> ::= ++ | -- | EMPTY
     */
	private Expr parseUnaryPostfix()
	{
		int position = this.currentToken.position;
		Expr result = null;
		
		Expr primary = this.parsePrimary();
		
		if (this.currentToken.kind == UNARYINCR)
		{
			//post-increment
			result = new UnaryIncrExpr(position, primary, true);
		}
		else if (this.currentToken.kind == UNARYDECR)
		{
			//post-decrement
			result = new UnaryDecrExpr(position, primary, true);
		}
		else
		{
			//no postfix
			result = primary;
		}
		
		return result;
	}

    /*
     * <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> | <VarExpr> | <DispatchExpr>
     * <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
     * <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
     * <VarExprSuffix> ::= [ <Expr> ] | EMPTY
     * <DispatchExpr> ::= <DispatchExprPrefix> <Identifier> ( <Arguments> )
     * <DispatchExprPrefix> ::= <Primary> . | EMPTY
     */
    private Expr parsePrimary()
    {
        int lineNum = this.currentToken.position;

        if (this.currentToken.kind == LPAREN)
        {
            this.currentToken = this.scanner.scan();
            Expr primary = parseExpression();

            //this.currentToken = this.scanner.scan();
            if (this.currentToken.kind != RPAREN)
                this.whinge("Expected closing parenthesis");

            this.currentToken = this.scanner.scan();
            return primary;
        }
        else if(this.currentToken.kind == INTCONST)
        {
            return parseIntConst();
        }
        else if(this.currentToken.kind == BOOLEAN)
        {
            return parseBoolean();
        }
        else if(this.currentToken.kind == STRCONST)
        {
            return parseStringConst();
        }
        else if(this.currentToken.kind == IDENTIFIER)  // ugly
        {
            if (this.currentToken.spelling.equals("super") || this.currentToken.spelling.equals("this"))
            {

            }
        }
        else
            this.whinge("");

        return null;
    }
    /*
     * <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> | <VarExpr> | <DispatchExpr>
     * <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
     * <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
     * <VarExprSuffix> ::= [ <Expr> ] | EMPTY
     * <DispatchExpr> ::= <DispatchExprPrefix> <Identifier> ( <Arguments> )
     * <DispatchExprPrefix> ::= <Primary> . | EMPTY
     */


    /*
     * <Arguments> ::= EMPTY | <Expression> <MoreArgs>
     * <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
     */
	private ExprList parseArguments()
	{
		int position = this.currentToken.position;
		ExprList argList = new ExprList(position);
		
		//parse first argument, which is always present
		argList.addElement(this.parseExpression());
		
		//parse other arguments if present
		while (this.currentToken.kind == COMMA)
		{
			this.currentToken = this.scanner.scan(); //move past comma
			argList.addElement(this.parseExpression());
		}
		
		return argList;
	}

    //----------------------------------------
    //Terminals

    /*
     * <Formal> ::= <Type> <Identifier>
     */
    private Formal parseFormal()
    {
        int lineNum = this.currentToken.position;
        String type = "";
        String name = "";

        if (this.currentToken.kind == IDENTIFIER)
        {
            type = parseIdentifier();
        }
        else
            this.whinge("Expected valid type name");

        //this.currentToken = this.scanner.scan();
        if (this.currentToken.kind == LBRACKET)  // optional brackets
        {
            this.currentToken = this.scanner.scan();
            if (this.currentToken.kind != RBRACKET)
                this.whinge("Expected closing bracket");

            this.currentToken = this.scanner.scan();
        }

        if (this.currentToken.kind == IDENTIFIER)
        {
            name = parseIdentifier();
        }
        else
            this.whinge("Expected identifier or opening bracket");

        //this.currentToken = this.scanner.scan();

        return new Formal(lineNum, type, name);
    }

    private String parseOperator()
    {
        String operator = this.currentToken.spelling;

        this.currentToken = this.scanner.scan();

        return operator;
    }

    private ConstStringExpr parseStringConst()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.currentToken = this.scanner.scan();

        return new ConstStringExpr(lineNum, constant);
    }


    private ConstIntExpr parseIntConst()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.currentToken = this.scanner.scan();

        return new ConstIntExpr(lineNum, constant);
    }


    private ConstBooleanExpr parseBoolean()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.currentToken = this.scanner.scan();

        return new ConstBooleanExpr(lineNum, constant);
    }
}

/*
Token ambiguous;
            String name = "";

            ambiguous = this.currentToken;  // might be name if no prefix

            this.currentToken = this.scanner.scan();
            if(this.currentToken.kind == DOT)
            {
                this.currentToken = this.scanner.scan();

                if( !(ambiguous.spelling.equals("super") || ambiguous.spelling.equals("this")) )
                    Expr primary =

                if(this.currentToken.kind == IDENTIFIER)
                {
                    name = this.currentToken.spelling;
                }
            }
            else if(this.currentToken.kind == LBRACKET)
            {
                name = ambiguous.spelling;
                ambiguous = null;

                return new VarExpr(lineNum, null, name);
            }
            else if(this.currentToken.kind == LPAREN)
            {
                name = ambiguous.spelling;
                ambiguous = null;

                this.currentToken = this.scanner.scan();
                ExprList actualList = parseArguments();

                if(this.currentToken.kind != RPAREN)
                    this.whinge("Expecting closing parenthesis");

                this.currentToken = this.scanner.scan();
                return new DispatchExpr(lineNum, null, name, actualList);
            }
            else
            {
                // is there a way to catch errors here?
                name = ambiguous.spelling;
                ambiguous = null;

                return new VarExpr(lineNum, null, name);
            }





            new VarExpr(lineNum, );
            new DispatchExpr(lineNum, );
 */
