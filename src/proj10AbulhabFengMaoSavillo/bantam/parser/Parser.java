/*
 * Authors: Haoyu Song and Dale Skrien
 * Date: Spring and Summer, 2018
 *
 * In the grammar below, the variables are enclosed in angle brackets.
 * The notation "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * All other symbols in the rules are terminals.
 * EMPTY indicates a rule with an empty right hand side.
 * All other terminal symbols that are in all caps correspond to keywords.
 */

package proj10AbulhabFengMaoSavillo.bantam.parser;

import proj10AbulhabFengMaoSavillo.bantam.lexer.*;
import proj10AbulhabFengMaoSavillo.bantam.util.*;

import static proj10AbulhabFengMaoSavillo.bantam.lexer.Token.Kind.*;

import proj10AbulhabFengMaoSavillo.bantam.ast.*;
import proj10AbulhabFengMaoSavillo.bantam.util.Error;


/**
 * This class constructs an AST from a legal Bantam Java program.  If the
 * program is illegal, then one or more error messages are displayed.
 */
public class Parser
{
    // instance variables
    private Scanner scanner;
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler;
    private String filename;

    // constructor
    public Parser(ErrorHandler errorHandler)
    {
        this.errorHandler = errorHandler;
        scanner = new Scanner(errorHandler);
    }

    /**
     * Test code for Parser
     */
    public static void main(String[] args)
    {
        //make sure at least one filename was given
        if (args.length < 1)
        {
            System.err.println("Missing input filename");
            System.exit(-1);
        }

        //for each file given, scan
        ErrorHandler errorHandler = new ErrorHandler();
        for (String filename : args)
        {
            System.out.println("Scanning file: " + filename + "\n");

            //scan tokens
            try
            {
//				Scanner scanner = new Scanner(filename, errorHandler);
//				Token currentToken = scanner.scan();
//				while (currentToken.kind != Token.Kind.EOF)
//				{
//					System.out.println(currentToken);
//					currentToken = scanner.scan();
//				}
                Parser parser = new Parser(errorHandler);
                parser.parse(filename);
            }
            catch (CompilationException e)
            {
                errorHandler.register(Error.Kind.LEX_ERROR, "Failed to complete parsing");
            }

            //check for errors
            if (errorHandler.errorsFound())
            {
                errorHandler.getErrorList().forEach(error -> System.out.println(error.toString()));
                System.out.println(String.format("\n%d errors found", errorHandler.getErrorList().size()));
            }
            else
            {
                System.out.println("\nScanning was successful");
            }

            System.out.println("-----------------------------------------------");

            //clear errors to scan next file
            errorHandler.clear();
        }
    }

    /**
     * parse the given file and return the root node of the AST
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename)
    {
        this.scanner.setSourceFile(filename);
        this.currentToken = scanner.scan();
        this.filename = filename;
        return (parseProgram());
    }

    /*
     * <Program> ::= <Class> | <Class> <Program>
     */
    private Program parseProgram()
    {
        this.advancePastCommentary();
        int position = this.currentToken.position;
        ClassList classList = new ClassList(position);

        while (currentToken.kind != EOF)
        {
            Class_ aClass = parseClass();
            classList.addElement(aClass);
        }

        return new Program(position, classList);
    }

    /**
     * Eats comments
     */
    private void advancePastCommentary()
    {
        while (this.currentToken.kind == COMMENT)
        {
            this.currentToken = this.scanner.scan();
        }
    }

    /*
     * <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
     * <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
     * <MemberList> ::= EMPTY | <Member> <MemberList>
     */
    private Class_ parseClass()
    {
        this.advancePastCommentary();
        int initialPosition = this.currentToken.position;
        String className = "";
        String parent = "";
        MemberList memberList = new MemberList(initialPosition);

        if (this.currentToken.kind == CLASS)
        {
            this.currentToken = this.scanner.scan();
            if (this.currentToken.kind == IDENTIFIER)
            {
                className = this.currentToken.spelling;
            }
            else
            {
                this.whinge("Expecting valid class name in class declaration.");
            }

            this.currentToken = scanner.scan();
            if (this.currentToken.kind == EXTENDS)
            {
                this.currentToken = scanner.scan();
                if (this.currentToken.kind == IDENTIFIER)
                {
                    parent = this.currentToken.spelling;
                    this.currentToken = scanner.scan();
                }
                else
                {
                    this.whinge("Missing name of class to extend in class declaration.");
                }
            }

            if (this.currentToken.kind != LCURLY)
            {
                this.whinge("Expected left brace.");
            }

            this.currentToken = this.scanner.scan();
            while (this.currentToken.kind != RCURLY)
            {
                Member member = parseMember();
                memberList.addElement(member);
            }

            this.currentToken = this.scanner.scan();

            Class_ class_ = new Class_(initialPosition, this.filename, className, parent, memberList);
            System.out.println(class_.getFilename());
            System.out.println(class_.getName());
            System.out.println(class_.getParent());
            System.out.println(class_.getMemberList());

        }

        return new Class_(initialPosition, className, className, parent, memberList);
    }

    /**
     * Parsing Error occurred!
     *
     * @param errorMessage
     * @throws CompilationException
     */
    private void whinge(String errorMessage)
            throws CompilationException
    {
        this.errorHandler.register(Error.Kind.PARSE_ERROR,
                                   this.filename,
                                   this.currentToken.position,
                                   errorMessage);
        throw new CompilationException(String.format("Compilation Exception: %s", errorMessage));
    }

    /* Fields and Methods
     * <Member> ::= <Field> | <Method>
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <InitialValue> ::= EMPTY | = <Expression>
     */
    private Member parseMember()
    {
        int position = this.currentToken.position;
        String type = this.parseType();
        String nameIdentifier = this.parseIdentifier();
        Member member = null;

        //if member matches form for a method
        if (this.currentToken.kind == LPAREN)
        {
            this.currentToken = this.scanner.scan();
            FormalList params = this.parseParameters();

            //check for closing parenthesis
            if (this.currentToken.kind != RPAREN)
            {
                this.whinge("Missing closing parenthesis in method declaration.");
            }
            else //if present, move on to next token
            {
                this.currentToken = this.scanner.scan();
            }

            BlockStmt block = (BlockStmt) this.parseBlock();
            StmtList blockStmts = block.getStmtList();

            member = new Method(position, type, nameIdentifier,
                                params, blockStmts);
        }
        else //otherwise parse member as field
        {
            if (this.currentToken.kind == SEMICOLON)
            {
                //empty initial value
                member = new Field(position, type, nameIdentifier, null);
            }
            else if (this.currentToken.kind == ASSIGN)
            {
                //non-empty initial value
                this.currentToken = this.scanner.scan(); //read past =
                Expr initValueExpr = this.parseExpression();

                //check for semicolon
                if (this.currentToken.kind != SEMICOLON)
                {
                    this.whinge("Missing ending semicolon in field declaration.");
                }
                else
                {
                    member = new Field(position, type, nameIdentifier, initValueExpr);
                }
            }
            else
            {
                //invalid syntax
                this.whinge("Invalid field declaration.");
            }

            //move past ending semicolon
            this.currentToken = this.scanner.scan();
        }

        return member;
    }

    //-----------------------------------

    /*
     * <BlockStmt> ::= { <Body> }
     * <Body> ::= EMPTY | <Stmt> <Body>
     */
    private Stmt parseBlock()
    {
        int lineNum = this.currentToken.position;
        BlockStmt blockStmt = null;

        if (this.currentToken.kind == LCURLY)
        {
            this.currentToken = this.scanner.scan();

            StmtList stmtList = new StmtList(lineNum);
            while (this.currentToken.kind != RCURLY)
            {
                if (this.currentToken.kind == EOF)
                    this.whinge("Expected closing brace");

                advancePastCommentary();
                Stmt stmt = parseStatement();
                stmtList.addElement(stmt);
            }
            blockStmt = new BlockStmt(lineNum, stmtList);
        }
        else
            this.whinge("Expected opening brace");

        return blockStmt;
    }

    /*
     * <Expression> ::= <LogicalOrExpr> <OptionalAssignment>
     * <OptionalAssignment> ::= EMPTY | = <Expression>
     */
    private Expr parseExpression()
    {
        int lineNum = this.currentToken.position;
        Expr expr = parseOrExpr();

        // if optional assignment present
        if (this.currentToken.kind == ASSIGN)
        {
            //make sure left-hand side of assignment is a var
            if (!(expr instanceof VarExpr))
                this.whinge("Expected var expression");

            String name = ((VarExpr)(expr)).getName();


            Expr assignedExpr = parseExpression();

            //if ref is given, get its name
            Expr ref = ((VarExpr)(expr)).getRef();
            String refName = null;
            if (ref != null)
            {
                //make sure ref is a VarExpr
                if (!(ref instanceof VarExpr))
                    this.whinge("Expected var expression");

                refName = ((VarExpr)ref).getName();
            }

            this.currentToken = this.scanner.scan(); //move past ASSIGN

            expr = new AssignExpr(lineNum, refName, name, assignedExpr);
        }

        return expr;
    }

    /*
     * <Parameters>  ::= EMPTY | <Formal> <MoreFormals>
     * <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals>
     */
    private FormalList parseParameters()
    {
        int lineNum = this.currentToken.position;
        FormalList formalList = new FormalList(lineNum);


        if (this.currentToken.kind == RPAREN) return formalList;

        formalList.addElement(this.parseFormal());

        // check any parameters that may be present
        while (this.currentToken.kind == COMMA)
        {

            this.currentToken = this.scanner.scan();
            Formal formal = parseFormal();
            formalList.addElement(formal);
        }

        return formalList;
    }

    /*
     * <Type> ::= <Identifier> <Brackets>
     * <Brackets> ::= EMPTY | [ ]
     */
    private String parseType()
    {
        String type = parseIdentifier();

        if (currentToken.kind == LBRACKET) // check for brackets
        {
            this.currentToken = scanner.scan();

            if (currentToken.kind != RBRACKET)
                this.whinge("Expected closing bracket");

            type += "[]";

            this.currentToken = this.scanner.scan();
        }

        return type;
    }

    private String parseIdentifier()
    {
        if (currentToken.kind != IDENTIFIER)
            this.whinge("Expected identifier");

        return currentToken.getSpelling();
    }

    /* Statements
     *  <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <DeclStmt>
     *              | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
     */
    private Stmt parseStatement()
    {
        Stmt stmt;

        switch (currentToken.kind)
        {
            case IF:
                stmt = parseIf();
                break;
            case LCURLY:
                stmt = parseBlock();
                break;
            case VAR:
                stmt = parseDeclStmt();
                break;
            case RETURN:
                stmt = parseReturn();
                break;
            case FOR:
                stmt = parseFor();
                break;
            case WHILE:
                stmt = parseWhile();
                break;
            case BREAK:
                stmt = parseBreak();
                break;
            default:
                stmt = parseExpressionStmt();
        }

        return stmt;
    }

    /*
     * <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
     */
    private Stmt parseWhile()
    {
        int lineNum = this.currentToken.position;

        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind == LPAREN)
        {
            this.currentToken = this.scanner.scan();
            Expr expr = parseExpression();

            if (this.currentToken.kind == RPAREN)
            {
                this.currentToken = this.scanner.scan();
                Stmt stmt = parseStatement();

                return new WhileStmt(lineNum, expr, stmt);
            }
            else
                this.whinge("Expected closing parenthesis!!");
        }
        else
            this.whinge("Expected opening parenthesis");

        return null;
    }

    /*
     * <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
     */
    private Stmt parseReturn()
    {
        Expr expr = null;
        int lineNum = this.currentToken.position;

        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind != SEMICOLON)
        {
            expr = parseExpression();
            checkSemicolon();
        }
        else
        {
            this.currentToken = this.scanner.scan();
        }

        return new ReturnStmt(lineNum, expr);
    }

    /*
     * BreakStmt> ::= BREAK ;
     */
    private Stmt parseBreak()
    {
        int lineNum = this.currentToken.position;
        this.currentToken = this.scanner.scan();
        checkSemicolon();

        return new BreakStmt(lineNum);
    }

    //-----------------------------------------
    // Expressions
    //Here we introduce the precedence to operations

    /*
     * <ExpressionStmt> ::= <Expression> ;
     */
    private ExprStmt parseExpressionStmt()
    {
        advancePastCommentary();
        int lineNum = this.currentToken.position;
        Expr expr = parseExpression();
        this.checkSemicolon();

        return new ExprStmt(lineNum, expr);
    }

    /*
     * <DeclStmt> ::= VAR <Identifier> = <Expression> ;
     * every local variable must be initialized
     */
    private Stmt parseDeclStmt()
    {
        int lineNum = this.currentToken.position;

        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind == IDENTIFIER)
        {
            String identifier = parseIdentifier();

            if (this.currentToken.kind == ASSIGN)
            {
                Expr expr = parseExpression();
                this.checkSemicolon();

                return new DeclStmt(lineNum, identifier, expr);
            }
            else
                whinge("Expected assignment sign");
        }
        else
            whinge("Expected identifier");

        return null;
    }

    /*
     * <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
     * <Start>     ::= EMPTY | <Expression>
     * <Terminate> ::= EMPTY | <Expression>
     * <Increment> ::= EMPTY | <Expression>
     */
    private Stmt parseFor()
    {
        Expr start = null;
        Expr terminate = null;
        Expr increment = null;

        int lineNum = this.currentToken.position;

        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis");

        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind != SEMICOLON)
        {
            start = parseExpression();
            this.checkSemicolon();
        }
        else
            this.currentToken = this.scanner.scan();

        if (this.currentToken.kind != SEMICOLON)
        {
            terminate = parseExpression();
            this.checkSemicolon();
        }
        else
            this.currentToken = this.scanner.scan();

        if (this.currentToken.kind != RPAREN)
        {
            increment = parseExpression();

            this.currentToken = this.scanner.scan();
            if (this.currentToken.kind != RPAREN)
                this.whinge("Expected closing parenthesis");
        }
        else
            this.currentToken = this.scanner.scan();

        Stmt bodyStmt = parseStatement();

        return new ForStmt(lineNum, start, terminate, increment, bodyStmt);
    }

    /*
     * <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
     */
    private Stmt parseIf()
    {
        Expr expr = null;
        Stmt thenStmt = null;
        Stmt elseStmt = null;

        int lineNum = currentToken.position;

        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis");

        this.currentToken = this.scanner.scan();
        expr = parseExpression();

        if (this.currentToken.kind != RPAREN)
            this.whinge("Expected closing parenthesis");

        this.currentToken = this.scanner.scan();
        thenStmt = parseStatement();

        if (this.currentToken.kind == ELSE)
        {
            this.currentToken = this.scanner.scan();
            elseStmt = parseStatement();
        }

        return new IfStmt(lineNum, expr, thenStmt, elseStmt);
    }

    /*
     * <LogicalOR> ::= <logicalAND> <LogicalORRest>
     * <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
     */
    private Expr parseOrExpr()
    {
        int lineNum = this.currentToken.position;

        Expr left = parseAndExpr();
        while (this.currentToken.spelling.equals("||"))
        {
            this.currentToken = this.scanner.scan();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(lineNum, left, right);
        }

        return left;
    }

    /*
     * <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
     * <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
     */
    private Expr parseAndExpr()
    {
        int lineNum = currentToken.position;

        Expr left = parseEqualityExpr();
        while (this.currentToken.spelling.equals("&&"))
        {
            this.currentToken = this.scanner.scan();
            Expr right = parseEqualityExpr();
            left = new BinaryLogicAndExpr(lineNum, left, right);
        }

        return left;
    }

    /*
     * <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
     *                     <RelationalExpr>
     * <equalOrNotEqual> ::=  == | !=
     */
    private Expr parseEqualityExpr()
    {
        int lineNum = currentToken.position;
        Expr left = parseRelationalExpr();
        Expr right = null;
        Expr expr = null;

        this.currentToken = scanner.scan();
        if (this.currentToken.spelling.equals("=="))
        {
            this.currentToken = this.scanner.scan();
            right = parseRelationalExpr();
            expr = new BinaryCompEqExpr(lineNum, left, right);
        }
        else if (this.currentToken.spelling.equals("!="))
        {
            this.currentToken = this.scanner.scan();
            right = parseRelationalExpr();
            expr = new BinaryCompNeExpr(lineNum, left, right);
        }
        else
        {
            expr = left;
        }

        return expr;
    }

    /*
     * <RelationalExpr> ::=<AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
     * <ComparisonOp> ::=  < | > | <= | >= | INSTANCEOF
     */
    private Expr parseRelationalExpr()
    {
        int lineNum = this.currentToken.position;
        Expr left = parseAddExpr();
        Expr right = null;
        Expr expr = null;

        this.currentToken = this.scanner.scan();
        switch (this.currentToken.spelling)
        {
            case "<":
                this.currentToken = this.scanner.scan();
                right = parseAddExpr();
                expr = new BinaryCompLtExpr(lineNum, left, right);
                break;
            case ">":
                this.currentToken = this.scanner.scan();
                right = parseAddExpr();
                expr = new BinaryCompGtExpr(lineNum, left, right);
                break;
            case "<=":
                this.currentToken = this.scanner.scan();
                right = parseAddExpr();
                expr = new BinaryCompLeqExpr(lineNum, left, right);
                break;
            case ">=":
                this.currentToken = this.scanner.scan();
                right = parseAddExpr();
                expr = new BinaryCompGeqExpr(lineNum, left, right);
                break;
            case "INSTANCEOF":
                this.currentToken = this.scanner.scan();
                String type = parseType();
                expr = new InstanceofExpr(lineNum, left, type);
                break;
            default:
                expr = left;
        }

        return expr;
    }

    /*
     * <AddExpr>::Ôºù <MultExpr> <MoreMultExpr>
     * <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
     */
    private Expr parseAddExpr()
    {
        int lineNum = currentToken.position;

        Expr left = parseMultExpr();
        while (this.currentToken.kind == PLUSMINUS)
        {
            if (this.currentToken.spelling.equals("+"))
            {
                this.currentToken = this.scanner.scan();
                Expr right = parseMultExpr();
                left = new BinaryArithPlusExpr(lineNum, left, right);
            }
            else if (this.currentToken.spelling.equals("-"))
            {
                this.currentToken = this.scanner.scan();
                Expr right = parseMultExpr();
                left = new BinaryArithMinusExpr(lineNum, left, right);
            }
        }
        return left;
    }

    /*
     * <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
     * <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
     *               / <NewCastOrUnary> <MoreNCU> |
     *               % <NewCastOrUnary> <MoreNCU> |
     *               EMPTY
     */
    private Expr parseMultExpr()
    {
        int lineNum = this.currentToken.position;
        Expr result = this.parseNewCastOrUnary();

        //build rest of MultiExpr while there are more operands
        Expr right;
        while (this.currentToken.kind == MULDIV)
        {
            switch (this.currentToken.spelling)
            {
                case "*":
                    //multiply
                    this.currentToken = this.scanner.scan();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithTimesExpr(lineNum, result, right);
                    break;
                case "/":
                    //divide
                    this.currentToken = this.scanner.scan();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithDivideExpr(lineNum, result, right);
                    break;
                case "%":
                    //modulo
                    this.currentToken = this.scanner.scan();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithModulusExpr(lineNum, result, right);
                    break;
            }
        }

        return result;
    }

    /*
     * <NewCastOrUnary> ::= <NewExpression> | <CastExpression> | <UnaryPrefix>
     */
    private Expr parseNewCastOrUnary()
    {
        Expr expr;
        //determine which rule to follow based on first token
        if (this.currentToken.kind == NEW)
        {
            expr = this.parseNew();
        }
        else if (this.currentToken.kind == CAST)
        {
            expr = this.parseCast();
        }
        else
        {
            expr = this.parseUnaryPrefix();
        }
        return expr;
    }

    /*
     * <NewExpression> ::= NEW <Identifier> ( ) | NEW <Identifier> [ <Expression> ]
     */
    private Expr parseNew()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        this.currentToken = this.scanner.scan(); //move past NEW
        String type = this.parseIdentifier();

        //handle new object
        if (this.currentToken.kind == LPAREN)
        {
            result = new NewExpr(lineNum, type);

            //check for closing parenthesis
            this.currentToken = this.scanner.scan();
            if (this.currentToken.kind != RPAREN)
            {
                this.whinge("Expected closing parenthesis in new object expression.");
            }
            else
            {
                this.currentToken = this.scanner.scan();
            }
        }
        //handle new array
        else if (this.currentToken.kind == LBRACKET)
        {
            this.currentToken = this.scanner.scan();
            Expr size = this.parseExpression();

            result = new NewArrayExpr(lineNum, type, size);

            //check for closing bracket
            if (this.currentToken.kind != RBRACKET)
            {
                this.whinge("Expected closing bracket in new array expression.");
            }
            else
            {
                this.currentToken = this.scanner.scan();
            }
        }
        else
        {
            this.whinge("Invalid new object/array expression.");
        }

        return result;
    }

    /*
     * <CastExpression> ::= CAST ( <Type> , <Expression> )
     */
    private Expr parseCast()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis in cast expression.");


        this.currentToken = this.scanner.scan();
        String type = this.parseType();

        //check for comma
        this.currentToken = this.scanner.scan();
        if (this.currentToken.kind != COMMA)
            this.whinge("Expected comma in cast expression.");

        this.currentToken = this.scanner.scan();
        Expr castedExpr = this.parseExpression();
        result = new CastExpr(lineNum, type, castedExpr);

        //check for closing parenthesis
        if (this.currentToken.kind != RPAREN)
            this.whinge("Expected closing parenthesis in cast expression.");

        this.currentToken = this.scanner.scan();

        return result;
    }

    /*
     * <UnaryPrefix> ::= <PrefixOp> <UnaryPrefix> | <UnaryPostfix>
     * <PrefixOp> ::= - | ! | ++ | --
     */
    private Expr parseUnaryPrefix()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        switch (this.currentToken.kind)
        {
            case PLUSMINUS:
                //unary negation

                //check to make sure not +
                if (this.currentToken.spelling.equals("+"))
                {
                    this.whinge("Unexpected + prefix to expression.");
                }
                else
                {
                    this.currentToken = this.scanner.scan();
                    Expr innerPrefix = this.parseUnaryPrefix();
                    result = new UnaryNegExpr(lineNum, innerPrefix);
                }
                break;
            case UNARYNOT:
            {
                //unary not
                this.currentToken = this.scanner.scan();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryNotExpr(lineNum, innerPrefix);
                break;
            }
            case UNARYINCR:
            {
                //pre-increment
                this.currentToken = this.scanner.scan();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryIncrExpr(lineNum, innerPrefix, false);
                break;
            }
            case UNARYDECR:
            {
                //pre-decrement
                this.currentToken = this.scanner.scan();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryDecrExpr(lineNum, innerPrefix, false);
                break;
            }
            default:
                //no prefix (base case)
                result = this.parseUnaryPostfix();
                break;
        }

        return result;
    }

    /*
     * <UnaryPostfix> ::= <Primary> <PostfixOp>
     * <PostfixOp> ::= ++ | -- | EMPTY
     */
    private Expr parseUnaryPostfix()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        Expr primary = this.parsePrimary();

        if (this.currentToken.kind == UNARYINCR)
        {
            //post-increment
            result = new UnaryIncrExpr(lineNum, primary, true);
        }
        else if (this.currentToken.kind == UNARYDECR)
        {
            //post-decrement
            result = new UnaryDecrExpr(lineNum, primary, true);
        }
        else
        {
            //no postfix
            result = primary;
        }

        return result;
    }

    /*
     * <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> | <VarExpr> | <DispatchExpr>
     * <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
     * <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
     * <VarExprSuffix> ::= [ <Expr> ] | EMPTY
     * <DispatchExpr> ::= <DispatchExprPrefix> <Identifier> ( <Arguments> )
     * <DispatchExprPrefix> ::= <Primary> . | EMPTY
     */
    private Expr parsePrimary()
    {
        int lineNum = this.currentToken.position;
        Expr primary = null;
        
        //parse the starting primary
        
        if (this.currentToken.kind == LPAREN)
        {
            this.currentToken = this.scanner.scan();
            primary = parseExpression();

            if (this.currentToken.kind != RPAREN)
                this.whinge("Expected closing parenthesis");

            this.currentToken = this.scanner.scan();
        }
        else if (this.currentToken.kind == INTCONST)
        {
            primary = parseIntConst();
        }
        else if (this.currentToken.kind == BOOLEAN)
        {
            primary = parseBoolean();
        }
        else if (this.currentToken.kind == STRCONST)
        {
            primary = parseStringConst();
        }
        else if (this.currentToken.kind == IDENTIFIER)  // ugly
        {
            //check for possible VarExprPrefix
        	if (this.currentToken.spelling.equals("super") || this.currentToken.spelling.equals("this"))
            {
                //store ref
        		VarExpr ref = new VarExpr(lineNum, null, this.currentToken.spelling);
        		this.currentToken = this.scanner.scan();
                
        		//check for dot
        		if(this.currentToken.kind!=DOT)
                    this.whinge("Expected a dot");
                this.currentToken = this.scanner.scan();
                
                String name = parseIdentifier();
                
                //brackets indicate array expression
                if (this.currentToken.kind == LBRACKET)
                {
                    this.currentToken = this.scanner.scan();
                    Expr indexExpr = parseExpression();
                    
                    if (this.currentToken.kind != RBRACKET)
                        this.whinge("Expected closing bracket");
                    this.currentToken = this.scanner.scan();
                    
                    primary = new ArrayExpr(lineNum, ref, name, indexExpr);
                }
                //otherwise handle general variable expression
                else
                {
                	primary = new VarExpr(lineNum, ref, name);
                }
            }
            //otherwise could be VarExpr or DispatchExpr
        	else
        	{
        		String name = parseIdentifier();
        		
        		if (this.currentToken.kind == LBRACKET)
        		{
        			/* TODO: this is identical to the previous array expr case
        			 * besides the ref
        			 */
        			//array expression
                    this.currentToken = this.scanner.scan();
                    Expr indexExpr = parseExpression();
                    
                    if (this.currentToken.kind != RBRACKET)
                        this.whinge("Expected closing bracket");
                    this.currentToken = this.scanner.scan();
        			primary = new ArrayExpr(lineNum, null, name, indexExpr);
        		}
        		else if (this.currentToken.kind == LPAREN)
        		{
        			//dispatch expression
        			ExprList arguments = this.parseArguments();
                    
                    if (this.currentToken.kind != RPAREN)
                        this.whinge("Expected closing parenthesis");
                    this.currentToken = this.scanner.scan();
                    
        			primary = new DispatchExpr(lineNum, null, name, arguments);
        		}
        		else
        		{
        			//var expression
        			primary = new VarExpr(lineNum, null, name);
        		}
        	}
        }
        else
            this.whinge("Expected primary");
        
        //while there is more to this primary
        //TODO: I think that after this point only dispatch expressions are possible
        while (this.currentToken.kind == DOT)
        {
            this.currentToken = this.scanner.scan(); //move past DOT
        	lineNum = this.currentToken.position;
        	String name = parseIdentifier();
        	
        	//check for opening parenthesis
        	if (this.currentToken.kind != LPAREN)
	    		this.whinge("Expected opening parenthesis in dispatch expression");

			ExprList arguments = this.parseArguments();
            
            if (this.currentToken.kind != RPAREN)
                this.whinge("Expected closing parenthesis");
            this.currentToken = this.scanner.scan();
            
			primary = new DispatchExpr(lineNum, primary, name, arguments);
        }

        System.out.println("thinged");
        return primary;
    }
    /*
     * <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> | <VarExpr> | <DispatchExpr>
     * <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
     * <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
     * <VarExprSuffix> ::= [ <Expr> ] | EMPTY
     * <DispatchExpr> ::= <DispatchExprPrefix> <Identifier> ( <Arguments> )
     * <DispatchExprPrefix> ::= <Primary> . | EMPTY
     */


    /*
     * <Arguments> ::= EMPTY | <Expression> <MoreArgs>
     * <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
     */
    private ExprList parseArguments()
    {
        int lineNum = this.currentToken.position;
        ExprList argList = new ExprList(lineNum);

        if (this.currentToken.kind==RPAREN) return argList;

        //parse first argument
        argList.addElement(this.parseExpression());

        //parse other arguments if present
        while (this.currentToken.kind == COMMA)
        {
            this.currentToken = this.scanner.scan(); //move past comma
            argList.addElement(this.parseExpression());
        }

        return argList;
    }

    //----------------------------------------
    //Terminals

    /*
     * <Formal> ::= <Type> <Identifier>
     */
    private Formal parseFormal()
    {
        int lineNum = this.currentToken.position;
        String type = "";
        String name = "";

        if (this.currentToken.kind == IDENTIFIER)
        {
            type = parseIdentifier();
        }
        else
            this.whinge("Expected valid type name");

        if (this.currentToken.kind == LBRACKET)  // optional brackets
        {
            this.currentToken = this.scanner.scan();
            if (this.currentToken.kind != RBRACKET)
                this.whinge("Expected closing bracket");

            type += "[]";
            this.currentToken = this.scanner.scan();
        }

        if (this.currentToken.kind == IDENTIFIER)
        {
            name = parseIdentifier();
        }
        else
            this.whinge("Expected identifier or opening bracket");

        return new Formal(lineNum, type, name);
    }

    private String parseOperator()
    {
        String operator = this.currentToken.spelling;

        this.currentToken = this.scanner.scan();

        return operator;
    }

    private ConstStringExpr parseStringConst()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.currentToken = this.scanner.scan();

        return new ConstStringExpr(lineNum, constant);
    }


    private ConstIntExpr parseIntConst()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.currentToken = this.scanner.scan();

        return new ConstIntExpr(lineNum, constant);
    }


    private ConstBooleanExpr parseBoolean()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.currentToken = this.scanner.scan();

        return new ConstBooleanExpr(lineNum, constant);
    }

    /**
     * helper method to check semicolon
     */
    private void checkSemicolon()
    {
        if (this.currentToken.kind != SEMICOLON)
            this.whinge("Expected semicolon");
        this.currentToken = this.scanner.scan();
    }
}

/*
Token ambiguous;
            String name = "";

            ambiguous = this.currentToken;  // might be name if no prefix

            this.currentToken = this.scanner.scan();
            if(this.currentToken.kind == DOT)
            {
                this.currentToken = this.scanner.scan();

                if( !(ambiguous.spelling.equals("super") || ambiguous.spelling.equals("this")) )
                    Expr primary =

                if(this.currentToken.kind == IDENTIFIER)
                {
                    name = this.currentToken.spelling;
                }
            }
            else if(this.currentToken.kind == LBRACKET)
            {
                name = ambiguous.spelling;
                ambiguous = null;

                return new VarExpr(lineNum, null, name);
            }
            else if(this.currentToken.kind == LPAREN)
            {
                name = ambiguous.spelling;
                ambiguous = null;

                this.currentToken = this.scanner.scan();
                ExprList actualList = parseArguments();

                if(this.currentToken.kind != RPAREN)
                    this.whinge("Expecting closing parenthesis");

                this.currentToken = this.scanner.scan();
                return new DispatchExpr(lineNum, null, name, actualList);
            }
            else
            {
                // is there a way to catch errors here?
                name = ambiguous.spelling;
                ambiguous = null;

                return new VarExpr(lineNum, null, name);
            }





            new VarExpr(lineNum, );
            new DispatchExpr(lineNum, );
 */
