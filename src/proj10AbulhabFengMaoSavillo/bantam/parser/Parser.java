/*
 * Authors: Haoyu Song and Dale Skrien
 * Date: Spring and Summer, 2018
 *
 * In the grammar below, the variables are enclosed in angle brackets.
 * The notation "::=" is used instead of "-->" to separate a variable from its rules.
 * The special character "|" is used to separate the rules for each variable.
 * All other symbols in the rules are terminals.
 * EMPTY indicates a rule with an empty right hand side.
 * All other terminal symbols that are in all caps correspond to keywords.
 *
 * --------------------------------------------------------------------
 * Modification for CS361 Project 10
 * Authors: Zena Abulhab, Yi Feng, Melody Mao, Evan Savillo
 * Date: Dec 6, 2018
 *
 */

package proj10AbulhabFengMaoSavillo.bantam.parser;

import proj10AbulhabFengMaoSavillo.bantam.lexer.*;
import proj10AbulhabFengMaoSavillo.bantam.util.*;

import static proj10AbulhabFengMaoSavillo.bantam.lexer.Token.Kind.*;

import proj10AbulhabFengMaoSavillo.bantam.ast.*;
import proj10AbulhabFengMaoSavillo.bantam.util.Error;


/**
 * This class constructs an AST from a legal Bantam Java program.  If the
 * program is illegal, then one or more error messages are displayed.
 */
public class Parser
{
    // instance variables
    private Scanner scanner;
    private Token currentToken; // the lookahead token
    private ErrorHandler errorHandler;
    private String filename;

    // constructor
    public Parser(ErrorHandler errorHandler)
    {
        this.errorHandler = errorHandler;
        this.scanner = new Scanner(errorHandler);
    }

    /**
     * Test code for Parser
     */
    public static void main(String[] args)
    {
        //make sure at least one filename was given
        if (args.length < 1)
        {
            System.err.println("Missing input filename");
            System.exit(-1);
        }

        //for each file given, parse
        ErrorHandler errorHandler = new ErrorHandler();
        for (String filename : args)
        {
            System.out.println("Scanning and Parsing file: " + filename + "\n");

            //parse tokens
            try
            {
                Parser parser = new Parser(errorHandler);
                parser.parse(filename);
            }
            catch (CompilationException e)
            {
                errorHandler.register(Error.Kind.LEX_ERROR, "Failed parse");
            }

            //check for errors
            if (errorHandler.errorsFound())
            {
                errorHandler.getErrorList().forEach(error -> System.out.println(error.toString()));
                System.out.println(String.format("\n%d errors found", errorHandler.getErrorList().size()));
            }
            else
            {
                System.out.println("\nParsing successful");
            }

            System.out.println("-----------------------------------------------");

            //clear errors to parse next file
            errorHandler.clear();
        }
    }

    /**
     * parse the given file and return the root node of the AST
     *
     * @param filename The name of the Bantam Java file to be parsed
     * @return The Program node forming the root of the AST generated by the parser
     */
    public Program parse(String filename)
    {
        this.scanner.setSourceFile(filename);
        this.scanPastCommentary();
        this.filename = filename;
        return (parseProgram());
    }

    /*
     * <Program> ::= <Class> | <Class> <Program>
     */
    private Program parseProgram()
    {
        int position = this.currentToken.position;
        ClassList classList = new ClassList(position);

        while (currentToken.kind != EOF)
        {
            Class_ aClass = parseClass();
            classList.addElement(aClass);
        }

        return new Program(position, classList);
    }

    /**
     * advance to the next token, ignoring comments
     */
    private void scanPastCommentary()
    {
        this.currentToken = this.scanner.scan();
        
        while (this.currentToken.kind == COMMENT)
        {
            this.currentToken = this.scanner.scan();
        }
        //this.currentToken = this.scanner.scan();
    }

    /*
     * <Class> ::= CLASS <Identifier> <ExtendsClause> { <MemberList> }
     * <ExtendsClause> ::= EXTENDS <Identifier> | EMPTY
     * <MemberList> ::= EMPTY | <Member> <MemberList>
     */
    private Class_ parseClass()
    {
        int initialPosition = this.currentToken.position;
        String className = "";
        String parent = "";
        MemberList memberList = new MemberList(initialPosition);

        if (this.currentToken.kind == CLASS)
        {
            this.scanPastCommentary();
            if (this.currentToken.kind == IDENTIFIER)
            {
                className = this.currentToken.spelling;
            }
            else
            {
                this.whinge("Expecting valid class name in class declaration.");
            }

            this.scanPastCommentary();
            if (this.currentToken.kind == EXTENDS)
            {
                this.scanPastCommentary();
                if (this.currentToken.kind == IDENTIFIER)
                {
                    parent = this.currentToken.spelling;
                    this.scanPastCommentary();
                }
                else
                {
                    this.whinge("Missing name of class to extend in class declaration.");
                }
            }

            if (this.currentToken.kind != LCURLY)
            {
                this.whinge("Expected left brace.");
            }

            this.scanPastCommentary();
            while (this.currentToken.kind != RCURLY)
            {
                Member member = parseMember();
                memberList.addElement(member);
            }

            this.scanPastCommentary();
        }

        return new Class_(initialPosition, className, className, parent, memberList);
    }

    /* Fields and Methods
     * <Member> ::= <Field> | <Method>
     * <Method> ::= <Type> <Identifier> ( <Parameters> ) <Block>
     * <Field> ::= <Type> <Identifier> <InitialValue> ;
     * <InitialValue> ::= EMPTY | = <Expression>
     */
    private Member parseMember()
    {
        int position = this.currentToken.position;
        String type = this.parseType();
        String nameIdentifier = this.parseIdentifier();
        Member member = null;

        //if member matches form for a method
        if (this.currentToken.kind == LPAREN)
        {
            this.scanPastCommentary();
            FormalList params = this.parseParameters();

            //check for closing parenthesis
            if (this.currentToken.kind != RPAREN)
            {
                this.whinge("Missing closing parenthesis in method declaration.");
            }
            else //if present, move on to next token
            {
                this.scanPastCommentary();
            }

            BlockStmt block = (BlockStmt) this.parseBlock();
            StmtList blockStmts = block.getStmtList();

            member = new Method(position, type, nameIdentifier,
                                params, blockStmts);
        }
        else //otherwise parse member as field
        {
            if (this.currentToken.kind == SEMICOLON)
            {
                //empty initial value
                member = new Field(position, type, nameIdentifier, null);
            }
            else if (this.currentToken.kind == ASSIGN)
            {
                //non-empty initial value
                this.scanPastCommentary(); //read past =
                Expr initValueExpr = this.parseExpression();

                //check for semicolon
                if (this.currentToken.kind != SEMICOLON)
                {
                    this.whinge("Missing ending semicolon in field declaration.");
                }
                else
                {
                    member = new Field(position, type, nameIdentifier, initValueExpr);
                }
            }
            else
            {
                //invalid syntax
                this.whinge("Invalid field declaration.");
            }

            //move past ending semicolon
            this.scanPastCommentary();
        }

        return member;
    }

    //-----------------------------------

    /*
     * <BlockStmt> ::= { <Body> }
     * <Body> ::= EMPTY | <Stmt> <Body>
     */
    private Stmt parseBlock()
    {
        int lineNum = this.currentToken.position;
        BlockStmt blockStmt = null;

        if (this.currentToken.kind != LCURLY)
            this.whinge("Expected opening brace");

        this.scanPastCommentary();

        StmtList stmtList = new StmtList(lineNum);
        while (this.currentToken.kind != RCURLY)
        {
            if (this.currentToken.kind == EOF)
                this.whinge("Expected closing brace");

            Stmt stmt = parseStatement();
            stmtList.addElement(stmt);
        }
        blockStmt = new BlockStmt(lineNum, stmtList);

        this.scanPastCommentary();

        return blockStmt;
    }

    /*
     * <Expression> ::= <LogicalOrExpr> <OptionalAssignment>
     * <OptionalAssignment> ::= EMPTY | = <Expression>
     */
    private Expr parseExpression()
    {
        int lineNum = this.currentToken.position;
        Expr expr = parseOrExpr();

        // if optional assignment present
        if (this.currentToken.kind == ASSIGN)
        {
            //left-hand side of assignment must be a var or array expr
        	if (expr instanceof VarExpr)
            {
        		String name = ((VarExpr) (expr)).getName();
        		Expr ref = ((VarExpr) (expr)).getRef();

        		//if ref is given, get its name
                String refName = null;
                if (ref != null)
                {
                    //make sure ref is a VarExpr
                    if (!(ref instanceof VarExpr))
                        this.whinge("Expected var expression");

                    refName = ((VarExpr) ref).getName();
                }

                this.scanPastCommentary(); //move past ASSIGN
                Expr assignedExpr = parseExpression();

                expr = new AssignExpr(lineNum, refName, name, assignedExpr);
            }
            else if (expr instanceof ArrayExpr)
            {
            	String name = ((ArrayExpr) (expr)).getName();
            	Expr ref = ((ArrayExpr) (expr)).getRef();
            	Expr indexExpr = ((ArrayExpr) (expr)).getIndex();

        		//if ref is given, get its name
                String refName = null;
                if (ref != null)
                {
                    //make sure ref is a VarExpr
                    if (!(ref instanceof VarExpr))
                        this.whinge("Expected var expression");

                    refName = ((VarExpr) ref).getName();
                }

                this.scanPastCommentary(); //move past ASSIGN
                Expr assignedExpr = parseExpression();

                expr = new ArrayAssignExpr(lineNum, refName, name, indexExpr, assignedExpr);
            }
            else
                this.whinge("Expected var or array expression to assign to");
        }

        return expr;
    }

    /*
     * <Parameters>  ::= EMPTY | <Formal> <MoreFormals>
     * <MoreFormals> ::= EMPTY | , <Formal> <MoreFormals>
     */
    private FormalList parseParameters()
    {
        int lineNum = this.currentToken.position;
        FormalList formalList = new FormalList(lineNum);

        if (this.currentToken.kind == RPAREN) return formalList;

        formalList.addElement(this.parseFormal());

        // check any parameters that may be present
        while (this.currentToken.kind == COMMA)
        {

            this.scanPastCommentary();
            Formal formal = parseFormal();
            formalList.addElement(formal);
        }

        return formalList;
    }

    /*
     * <Type> ::= <Identifier> <Brackets>
     * <Brackets> ::= EMPTY | [ ]
     */
    private String parseType()
    {
        String type = parseIdentifier();

        if (currentToken.kind == LBRACKET) // check for brackets
        {
            this.scanPastCommentary();

            if (currentToken.kind != RBRACKET)
                this.whinge("Expected closing bracket");

            type += "[]";

            this.scanPastCommentary();
        }

        return type;
    }

    private String parseIdentifier()
    {
        if (this.currentToken.kind != IDENTIFIER)
            this.whinge("Expected identifier");

        String identifier = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return identifier;
    }

    /* Statements
     *  <Stmt> ::= <WhileStmt> | <ReturnStmt> | <BreakStmt> | <DeclStmt>
     *              | <ExpressionStmt> | <ForStmt> | <BlockStmt> | <IfStmt>
     */
    private Stmt parseStatement()
    {
        Stmt stmt;

        switch (currentToken.kind)
        {
            case IF:
                stmt = parseIf();
                break;
            case LCURLY:
                stmt = parseBlock();
                break;
            case VAR:
                stmt = parseDeclStmt();
                break;
            case RETURN:
                stmt = parseReturn();
                break;
            case FOR:
                stmt = parseFor();
                break;
            case WHILE:
                stmt = parseWhile();
                break;
            case BREAK:
                stmt = parseBreak();
                break;
            default:
                stmt = parseExpressionStmt();
        }

        return stmt;
    }

    /*
     * <WhileStmt> ::= WHILE ( <Expression> ) <Stmt>
     */
    private Stmt parseWhile()
    {
        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind == LPAREN)
        {
            this.scanPastCommentary();
            Expr expr = parseExpression();

            if (this.currentToken.kind == RPAREN)
            {
                this.scanPastCommentary();
                Stmt stmt = parseStatement();

                return new WhileStmt(lineNum, expr, stmt);
            }
            else
                this.whinge("Expected closing parenthesis!!");
        }
        else
            this.whinge("Expected opening parenthesis");

        return null;
    }

    /*
     * <ReturnStmt> ::= RETURN <Expression> ; | RETURN ;
     */
    private Stmt parseReturn()
    {
        Expr expr = null;
        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind != SEMICOLON)
        {
            expr = parseExpression();
            checkSemicolon();
        }
        else
        {
            this.scanPastCommentary();
        }

        return new ReturnStmt(lineNum, expr);
    }

    /*
     * BreakStmt> ::= BREAK ;
     */
    private Stmt parseBreak()
    {
        int lineNum = this.currentToken.position;
        this.scanPastCommentary();
        checkSemicolon();

        return new BreakStmt(lineNum);
    }

    //-----------------------------------------
    // Expressions
    //Here we introduce the precedence to operations

    /*
     * <ExpressionStmt> ::= <Expression> ;
     */
    private ExprStmt parseExpressionStmt()
    {
        int lineNum = this.currentToken.position;
        Expr expr = parseExpression();
        this.checkSemicolon();

        return new ExprStmt(lineNum, expr);
    }

    /*
     * <DeclStmt> ::= VAR <Identifier> = <Expression> ;
     * every local variable must be initialized
     */
    private Stmt parseDeclStmt()
    {
        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind == IDENTIFIER)
        {
            String identifier = parseIdentifier();

            if (this.currentToken.kind == ASSIGN)
            {
                this.scanPastCommentary();
                Expr expr = parseExpression();
                this.checkSemicolon();

                return new DeclStmt(lineNum, identifier, expr);
            }
            else
                whinge("Expected assignment sign");
        }
        else
            whinge("Expected identifier");

        return null;
    }

    /*
     * <ForStmt> ::= FOR ( <Start> ; <Terminate> ; <Increment> ) <STMT>
     * <Start>     ::= EMPTY | <Expression>
     * <Terminate> ::= EMPTY | <Expression>
     * <Increment> ::= EMPTY | <Expression>
     */
    private Stmt parseFor()
    {
        Expr start = null;
        Expr terminate = null;
        Expr increment = null;

        int lineNum = this.currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis");

        this.scanPastCommentary();
        if (this.currentToken.kind != SEMICOLON)
        {
            start = parseExpression();
            this.checkSemicolon();
        }
        else
            this.scanPastCommentary();

        if (this.currentToken.kind != SEMICOLON)
        {
            terminate = parseExpression();
            this.checkSemicolon();
        }
        else
            this.scanPastCommentary();

        if (this.currentToken.kind != RPAREN)
        {
            increment = parseExpression();

            if (this.currentToken.kind != RPAREN)
                this.whinge("Expected closing parenthesis");
            else
                this.scanPastCommentary();
        }
        else
            this.scanPastCommentary();

        Stmt bodyStmt = parseStatement();

        return new ForStmt(lineNum, start, terminate, increment, bodyStmt);
    }

    /*
     * <IfStmt> ::= IF ( <Expr> ) <Stmt> | IF ( <Expr> ) <Stmt> ELSE <Stmt>
     */
    private Stmt parseIf()
    {
        Expr expr = null;
        Stmt thenStmt = null;
        Stmt elseStmt = null;

        int lineNum = currentToken.position;

        this.scanPastCommentary();
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis");

        this.scanPastCommentary();
        expr = parseExpression();

        if (this.currentToken.kind != RPAREN)
            this.whinge("Expected closing parenthesis");

        this.scanPastCommentary();
        thenStmt = parseStatement();

        if (this.currentToken.kind == ELSE)
        {
            this.scanPastCommentary();
            elseStmt = parseStatement();
        }

        return new IfStmt(lineNum, expr, thenStmt, elseStmt);
    }

    /*
     * <LogicalOR> ::= <logicalAND> <LogicalORRest>
     * <LogicalORRest> ::= EMPTY |  || <LogicalAND> <LogicalORRest>
     */
    private Expr parseOrExpr()
    {
        int lineNum = this.currentToken.position;

        Expr left = parseAndExpr();
        while (this.currentToken.spelling.equals("||"))
        {
            this.scanPastCommentary();
            Expr right = parseAndExpr();
            left = new BinaryLogicOrExpr(lineNum, left, right);
        }

        return left;
    }

    /*
     * <LogicalAND> ::= <ComparisonExpr> <LogicalANDRest>
     * <LogicalANDRest> ::= EMPTY |  && <ComparisonExpr> <LogicalANDRest>
     */
    private Expr parseAndExpr()
    {
        int lineNum = currentToken.position;

        Expr left = parseEqualityExpr();
        while (this.currentToken.spelling.equals("&&"))
        {
            this.scanPastCommentary();
            Expr right = parseEqualityExpr();
            left = new BinaryLogicAndExpr(lineNum, left, right);
        }

        return left;
    }

    /*
     * <ComparisonExpr> ::= <RelationalExpr> <equalOrNotEqual> <RelationalExpr> |
     *                     <RelationalExpr>
     * <equalOrNotEqual> ::=  == | !=
     */
    private Expr parseEqualityExpr()
    {
        int lineNum = currentToken.position;
        Expr left = parseRelationalExpr();
        Expr right = null;
        Expr expr = null;

        if (this.currentToken.spelling.equals("=="))
        {
            this.scanPastCommentary();
            right = parseRelationalExpr();
            expr = new BinaryCompEqExpr(lineNum, left, right);
        }
        else if (this.currentToken.spelling.equals("!="))
        {
            this.scanPastCommentary();
            right = parseRelationalExpr();
            expr = new BinaryCompNeExpr(lineNum, left, right);
        }
        else
        {
            expr = left;
        }

        return expr;
    }

    /*
     * <RelationalExpr> ::=<AddExpr> | <AddExpr> <ComparisonOp> <AddExpr>
     * <ComparisonOp> ::=  < | > | <= | >= | INSTANCEOF
     */
    private Expr parseRelationalExpr()
    {
        int lineNum = this.currentToken.position;
        Expr left = parseAddExpr();
        Expr right = null;
        Expr expr = null;

        switch (this.currentToken.spelling)
        {
            case "<":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompLtExpr(lineNum, left, right);
                break;
            case ">":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompGtExpr(lineNum, left, right);
                break;
            case "<=":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompLeqExpr(lineNum, left, right);
                break;
            case ">=":
                this.scanPastCommentary();
                right = parseAddExpr();
                expr = new BinaryCompGeqExpr(lineNum, left, right);
                break;
            case "INSTANCEOF":
                this.scanPastCommentary();
                String type = parseType();
                expr = new InstanceofExpr(lineNum, left, type);
                break;
            default:
                expr = left;
        }

        return expr;
    }

    /*
     * <AddExpr>::Ôºù <MultExpr> <MoreMultExpr>
     * <MoreMultExpr> ::= EMPTY | + <MultExpr> <MoreMultExpr> | - <MultExpr> <MoreMultExpr>
     */
    private Expr parseAddExpr()
    {
        int lineNum = currentToken.position;

        Expr left = parseMultExpr();
        while (this.currentToken.kind == PLUSMINUS)
        {
            if (this.currentToken.spelling.equals("+"))
            {
                this.scanPastCommentary();
                Expr right = parseMultExpr();
                left = new BinaryArithPlusExpr(lineNum, left, right);
            }
            else if (this.currentToken.spelling.equals("-"))
            {
                this.scanPastCommentary();
                Expr right = parseMultExpr();
                left = new BinaryArithMinusExpr(lineNum, left, right);
            }
        }
        return left;
    }

    /*
     * <MultiExpr> ::= <NewCastOrUnary> <MoreNCU>
     * <MoreNCU> ::= * <NewCastOrUnary> <MoreNCU> |
     *               / <NewCastOrUnary> <MoreNCU> |
     *               % <NewCastOrUnary> <MoreNCU> |
     *               EMPTY
     */
    private Expr parseMultExpr()
    {
        int lineNum = this.currentToken.position;
        Expr result = this.parseNewCastOrUnary();

        //build rest of MultiExpr while there are more operands
        Expr right;
        while (this.currentToken.kind == MULDIV)
        {
            switch (this.currentToken.spelling)
            {
                case "*":
                    //multiply
                    this.scanPastCommentary();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithTimesExpr(lineNum, result, right);
                    break;
                case "/":
                    //divide
                    this.scanPastCommentary();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithDivideExpr(lineNum, result, right);
                    break;
                case "%":
                    //modulo
                    this.scanPastCommentary();
                    right = this.parseNewCastOrUnary();
                    result = new BinaryArithModulusExpr(lineNum, result, right);
                    break;
            }
        }

        return result;
    }

    /*
     * <NewCastOrUnary> ::= <NewExpression> | <CastExpression> | <UnaryPrefix>
     */
    private Expr parseNewCastOrUnary()
    {
        Expr expr;
        //determine which rule to follow based on first token
        if (this.currentToken.kind == NEW)
        {
            expr = this.parseNew();
        }
        else if (this.currentToken.kind == CAST)
        {
            expr = this.parseCast();
        }
        else
        {
            expr = this.parseUnaryPrefix();
        }
        return expr;
    }

    /*
     * <NewExpression> ::= NEW <Identifier> ( ) | NEW <Identifier> [ <Expression> ]
     */
    private Expr parseNew()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        this.scanPastCommentary(); //move past NEW
        String type = this.parseIdentifier();

        //handle new object
        if (this.currentToken.kind == LPAREN)
        {
            result = new NewExpr(lineNum, type);

            //check for closing parenthesis
            this.scanPastCommentary();
            if (this.currentToken.kind != RPAREN)
            {
                this.whinge("Expected closing parenthesis in new object expression.");
            }
            else
            {
                this.scanPastCommentary();
            }
        }
        //handle new array
        else if (this.currentToken.kind == LBRACKET)
        {
            this.scanPastCommentary();
            Expr size = this.parseExpression();

            result = new NewArrayExpr(lineNum, type, size);

            //check for closing bracket
            if (this.currentToken.kind != RBRACKET)
            {
                this.whinge("Expected closing bracket in new array expression.");
            }
            else
            {
                this.scanPastCommentary();
            }
        }
        else
        {
            this.whinge("Invalid new object/array expression.");
        }

        return result;
    }

    /*
     * <CastExpression> ::= CAST ( <Type> , <Expression> )
     */
    private Expr parseCast()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        this.scanPastCommentary(); //scan past CAST
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis in cast expression.");

        this.scanPastCommentary(); //scan past (
        String type = this.parseType();

        //check for comma
        if (this.currentToken.kind != COMMA)
            this.whinge("Expected comma in cast expression.");
        this.scanPastCommentary(); //scan past ,
        
        Expr castedExpr = this.parseExpression();
        result = new CastExpr(lineNum, type, castedExpr);

        //check for closing parenthesis
        if (this.currentToken.kind != RPAREN)
            this.whinge("Expected closing parenthesis in cast expression.");

        this.scanPastCommentary(); //scan past )

        return result;
    }

    /*
     * <UnaryPrefix> ::= <PrefixOp> <UnaryPrefix> | <UnaryPostfix>
     * <PrefixOp> ::= - | ! | ++ | --
     */
    private Expr parseUnaryPrefix()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        switch (this.currentToken.kind)
        {
            case PLUSMINUS:
                //unary negation

                //check to make sure not +
                if (this.currentToken.spelling.equals("+"))
                    this.whinge("Unexpected + prefix to expression.");
                else
                {
                    this.scanPastCommentary();
                    Expr innerPrefix = this.parseUnaryPrefix();
                    result = new UnaryNegExpr(lineNum, innerPrefix);
                }
                break;
            case UNARYNOT:
            {
                //unary not
                this.scanPastCommentary();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryNotExpr(lineNum, innerPrefix);
                break;
            }
            case UNARYINCR:
            {
                //pre-increment
                this.scanPastCommentary();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryIncrExpr(lineNum, innerPrefix, false);
                break;
            }
            case UNARYDECR:
            {
                //pre-decrement
                this.scanPastCommentary();
                Expr innerPrefix = this.parseUnaryPrefix();
                result = new UnaryDecrExpr(lineNum, innerPrefix, false);
                break;
            }
            default:
                //no prefix (base case)
                result = this.parseUnaryPostfix();
                break;
        }

        return result;
    }

    /*
     * <UnaryPostfix> ::= <Primary> <PostfixOp>
     * <PostfixOp> ::= ++ | -- | EMPTY
     */
    private Expr parseUnaryPostfix()
    {
        int lineNum = this.currentToken.position;
        Expr result = null;

        Expr primary = this.parsePrimary();

        if (this.currentToken.kind == UNARYINCR)
        {
            this.scanPastCommentary();
            //post-increment
            result = new UnaryIncrExpr(lineNum, primary, true);
        }
        else if (this.currentToken.kind == UNARYDECR)
        {
            this.scanPastCommentary();
            //post-decrement
            result = new UnaryDecrExpr(lineNum, primary, true);
        }
        else
        {
            //no postfix
            result = primary;
        }

        return result;
    }

    /*
     * <Primary> ::= ( <Expression> ) | <IntegerConst> | <BooleanConst> |
     *                               <StringConst> | <VarExpr> | <DispatchExpr>
     * <VarExpr> ::= <VarExprPrefix> <Identifier> <VarExprSuffix>
     * <VarExprPrefix> ::= SUPER . | THIS . | EMPTY
     * <VarExprSuffix> ::= [ <Expr> ] | EMPTY
     * <DispatchExpr> ::= <DispatchExprPrefix> <Identifier> ( <Arguments> )
     * <DispatchExprPrefix> ::= <Primary> . | EMPTY
     */
    private Expr parsePrimary()
    {
        int lineNum = this.currentToken.position;
        Expr primary = null;

        //parse the starting primary
        switch (this.currentToken.kind)
        {
	        case LPAREN:
	            this.scanPastCommentary();
	            primary = parseExpression();
	
	            if (this.currentToken.kind != RPAREN)
	                this.whinge("Expected closing parenthesis");
	
	            this.scanPastCommentary();
	            break;
	        case INTCONST:
	            primary = parseIntConst();
	            break;
	        case BOOLEAN:
	            primary = parseBoolean();
	            break;
	        case STRCONST:
	            primary = parseStringConst();
	            break;
	        case IDENTIFIER:
	        {
	            //check for possible VarExprPrefix
	            if (this.currentToken.spelling.equals("super") || this.currentToken.spelling.equals("this"))
	            {
	                //store ref
	                VarExpr ref = new VarExpr(lineNum, null, this.currentToken.spelling);
	                this.scanPastCommentary();
	
	                //check for dot
	                if (this.currentToken.kind != DOT)
	                    this.whinge("Expected a dot");
	                this.scanPastCommentary();
	
	                String name = parseIdentifier();
	
	                //brackets indicate array expression
	                if (this.currentToken.kind == LBRACKET)
	                {
	                    primary = parseArrayExprRest(lineNum, ref, name);
	                }
	                //otherwise handle general variable expression
	                else
	                {
	                    primary = new VarExpr(lineNum, ref, name);
	                }
	            }
	            //otherwise could be VarExpr or DispatchExpr
	            else
	            {
	                String name = parseIdentifier();
	
	                if (this.currentToken.kind == LBRACKET)
	                {
	                    //array expression
	                    primary = parseArrayExprRest(lineNum, null, name);
	                }
	                else if (this.currentToken.kind == LPAREN)
	                {
	                	this.scanPastCommentary();
	                    
	                	//dispatch expression
	                    ExprList arguments = this.parseArguments();
	
	                    if (this.currentToken.kind != RPAREN)
	                        this.whinge("Expected closing parenthesis in dispatch expression");
	                    this.scanPastCommentary();
	
	                    primary = new DispatchExpr(lineNum, null, name, arguments);
	                }
	                else
	                {
	                    //var expression
	                    primary = new VarExpr(lineNum, null, name);
	                }
	            }
	            break;
	        }
	        default:
	            this.whinge("Expected primary");
	            break;
        }

        //parse rest of primary if present (only dispatch expressions are allowed)
        //note: this does not handle being able to access the length of an array
        while (this.currentToken.kind == DOT)
        {
            primary = parseAdditionalDispatch(primary);
        }

        return primary;
    }

    /**
     * helper method for parsePrimary that parses the rest of an array expression
     * 
     * @param lineNum source line number of array expression
     * @param ref the optional reference object
     * @param name name of the variable
     * @return the parsed ArrayExpr
     */
    private ArrayExpr parseArrayExprRest(int lineNum, Expr ref, String name)
    {
    	this.scanPastCommentary();
        Expr indexExpr = parseExpression();

        if (this.currentToken.kind != RBRACKET)
            this.whinge("Expected closing bracket");
        this.scanPastCommentary();

        return new ArrayExpr(lineNum, ref, name, indexExpr);
    }
    
    /**
     * helper method for parsePrimary that parses a dispatch expression called
     * after a dot (note: this method handles the dot)
     * 
     * @param ref the optional reference object
     * @return the parsed DispatchExpr
     */
    private DispatchExpr parseAdditionalDispatch(Expr ref)
    {
    	this.scanPastCommentary(); //move past DOT
        int lineNum = this.currentToken.position;
        String name = parseIdentifier();

        //check for opening parenthesis
        if (this.currentToken.kind != LPAREN)
            this.whinge("Expected opening parenthesis in dispatch expression");
        this.scanPastCommentary();

        ExprList arguments = this.parseArguments();

        //check for closing parenthesis
        if (this.currentToken.kind != RPAREN)
            this.whinge("Expected closing parenthesis in dispatch expression");
        this.scanPastCommentary();

        return new DispatchExpr(lineNum, ref, name, arguments);
    }

    /*
     * <Arguments> ::= EMPTY | <Expression> <MoreArgs>
     * <MoreArgs>  ::= EMPTY | , <Expression> <MoreArgs>
     */
    private ExprList parseArguments()
    {
        int lineNum = this.currentToken.position;
        ExprList argList = new ExprList(lineNum);

        if (this.currentToken.kind == RPAREN) return argList;
        
        //parse first argument
        argList.addElement(this.parseExpression());
        
        //parse other arguments if present
        while (this.currentToken.kind == COMMA)
        {
            this.scanPastCommentary(); //move past comma
            argList.addElement(this.parseExpression());
        }
        
        return argList;
    }

    //----------------------------------------
    //Terminals

    /*
     * <Formal> ::= <Type> <Identifier>
     */
    private Formal parseFormal()
    {
        int lineNum = this.currentToken.position;
        String type = "";
        String name = "";

        if (this.currentToken.kind == IDENTIFIER)
        {
            type = parseIdentifier();
        }
        else
            this.whinge("Expected valid type name");

        if (this.currentToken.kind == LBRACKET)  // optional brackets
        {
            this.scanPastCommentary();
            if (this.currentToken.kind != RBRACKET)
                this.whinge("Expected closing bracket");

            type += "[]";
            this.scanPastCommentary();
        }

        if (this.currentToken.kind == IDENTIFIER)
        {
            name = parseIdentifier();
        }
        else
            this.whinge("Expected identifier or opening bracket");

        return new Formal(lineNum, type, name);
    }

    private String parseOperator()
    {
        String operator = this.currentToken.spelling;

        this.scanPastCommentary();

        return operator;
    }

    private ConstStringExpr parseStringConst()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return new ConstStringExpr(lineNum, constant);
    }


    private ConstIntExpr parseIntConst()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return new ConstIntExpr(lineNum, constant);
    }


    private ConstBooleanExpr parseBoolean()
    {
        int lineNum = this.currentToken.position;
        String constant = this.currentToken.getSpelling();

        this.scanPastCommentary();

        return new ConstBooleanExpr(lineNum, constant);
    }

    /**
     * helper method to check semicolon
     * if the current token is not semicolon, report error
     */
    private void checkSemicolon()
    {
        if (this.currentToken.kind != SEMICOLON)
            this.whinge("Expected semicolon");
        this.scanPastCommentary();
    }

    /**
     * register the encountered error to the error handler
     * throw a compilation exception
     *
     * @param errorMessage
     * @throws CompilationException
     */
    private void whinge(String errorMessage)
            throws CompilationException
    {
        this.errorHandler.register(Error.Kind.PARSE_ERROR,
                                   this.filename,
                                   this.currentToken.position,
                                   errorMessage);
        throw new CompilationException(String.format("Compilation Exception: %s", errorMessage));
    }
}